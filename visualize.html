<!doctype html>
<html>
    <head>
        <title>Surface</title>
        
        <script src="node_modules/vue/dist/vue.min.js"></script>
        <script src="node_modules/three/build/three.min.js"></script>
        <script src="node_modules/async/dist/async.min.js"></script>
        <script src="node_modules/dat.gui/build/dat.gui.min.js"></script>
        <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="node_modules/three/examples/js/loaders/VTKLoader.js"></script>
    </head>
    
    <body>
        <div id="main"></div>
        <script>
            'use strict';
            
            (async _ => {
            
            let scene1 = new THREE.Scene();
            let scene2 = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 10000);
            let renderer = new THREE.WebGLRenderer();
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            let loader = new THREE.VTKLoader();
            let gui = new dat.GUI();
            
            camera.position.z = 200;
            
            renderer.setClearColor(new THREE.Color(0x222222));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("main").appendChild(renderer.domElement);
            
            let labelFiles = ["lh.V1.label", "rh.V1.label"];
            // let labelFiles = ["lh.V1.label", "rh.V1.label", "lh.V2.label", "rh.V2.label", "lh.BA1.label", "rh.BA1.label", "lh.BA2.label", "rh.BA2.label", "lh.BA3a.label", "rh.BA3a.label", "lh.BA3b.label", "rh.BA3b.label", "lh.BA4a.label", "rh.BA4a.label", "lh.BA4p.label", "rh.BA4p.label", "lh.BA4p.thresh.label", "rh.BA4p.thresh.label", "lh.BA6.label", "rh.BA6.label", "lh.BA44.label", "rh.BA44.label", "lh.BA45.label", "rh.BA45.label", "lh.BA6.label", "rh.BA6.label", "lh.entorhinal_exvivo.label", "rh.entorhinal_exvivo.label", "lh.MT.label", "rh.MT.label", "lh.perirhinal.label", "rh.perirhinal.label"];
            // let labelFiles = ["rh.BA44.label", "lh.BA44.label", "lh.BA3b.thresh.label", "rh.BA6.thresh.label", "rh.BA45.label", "rh.BA2.thresh.label", "lh.entorhinal_exvivo.label", "lh.BA45.label", "lh.BA3a.thresh.label", "rh.V2.label", "rh.BA45.thresh.label", "rh.BA3b.label", "rh.BA1.thresh.label", "rh.BA1.label", "rh.BA44.thresh.label", "rh.BA2.label", "lh.BA3b.label", "rh.perirhinal.label", "rh.V1.label", "lh.BA6.label", "lh.BA3a.label", "rh.MT.label", "rh.BA4p.thresh.label", "rh.BA4p.label", "rh.BA3a.label", "lh.BA4p.label", "rh.BA4a.thresh.label", "lh.BA4a.thresh.label", "rh.entorhinal_exvivo.label", "lh.perirhinal.label", "rh.aparc.a2009s.annot", "lh.V1.label", "lh.BA1.label", "rh.cortex.prehires.label", "rh.cortex.deformed.label", "lh.cortex.prehires.label", "lh.aparc.annot", "lh.BA4p.thresh.label", "lh.MT.label", "lh.BA45.thresh.label", "lh.BA2.label", "rh.MT.thresh.label", "rh.BA6.label", "lh.V2.label", "lh.MT.thresh.label", "lh.BA6.thresh.label", "lh.BA44.thresh.label", "rh.V1.thresh.label", "rh.BA4a.label", "lh.cortex.deformed.label", "lh.V2.thresh.label", "lh.BA4a.label", "lh.BA2.thresh.label", "rh.V2.thresh.label", "rh.BA3b.thresh.label", "rh.BA3a.thresh.label", "lh.V1.thresh.label", "lh.BA1.thresh.label", "lh.cortex.label", "rh.cortex.label"]
            let left_labels = {};
            let right_labels = {};
            
            async.eachLimit(labelFiles, 10, function(filename, next_file) {
                console.log("loading", filename);
                loadLabels("input/output/label/" + filename)
                .then(_ => {
                    next_file();
                });
            }, async function(err) {
                if (err) console.error(err);
                console.log("loading lh.pial");
                let lh_pial_geometry = await loadVTK('input/output/surf/lh.pial.vtk');
                
                console.log("loading rh.pial");
                let rh_pial_geometry = await loadVTK('input/output/surf/rh.pial.vtk');
                
                console.log("loading lh.inflated");
                let lh_inflated_geometry = await loadVTK('input/output/surf/lh.inflated.vtk');
                
                console.log("loading rh.inflated");
                let rh_inflated_geometry = await loadVTK('input/output/surf/rh.inflated.vtk');
                
                let pointlight1 = new THREE.PointLight(0xffffff, 1);
                let pointlight2 = new THREE.PointLight(0xffffff, 1);
                
                let pial_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x2194ce), transparent: true, opacity: .7 });
                let inflated_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x9421ce), transparent: true, opacity: .7 });
                
                renderer.autoClear = false;
                
                lh_pial_geometry.computeVertexNormals();
                rh_pial_geometry.computeVertexNormals();
                
                lh_inflated_geometry.computeVertexNormals();
                rh_inflated_geometry.computeVertexNormals();
                
                pointlight1.position.copy(camera.position);
                pointlight2.position.copy(camera.position);
                
                scene1.add(pointlight1);
                scene2.add(pointlight2);
                
                console.log(lh_pial_geometry);
                console.log(lh_inflated_geometry);
                
                let lh_pial_mesh = new THREE.Mesh(lh_pial_geometry, createMaterial(lh_pial_geometry, 'l', lh_inflated_geometry));
                let rh_pial_mesh = new THREE.Mesh(rh_pial_geometry, createMaterial(rh_pial_geometry, 'r', rh_inflated_geometry));
                
                console.log(lh_pial_mesh);
                
                let lh_inflated_mesh = new THREE.Mesh(lh_inflated_geometry, createMaterial(lh_inflated_geometry, 'l'));
                let rh_inflated_mesh = new THREE.Mesh(rh_inflated_geometry, createMaterial(rh_inflated_geometry, 'r'));
                
                lh_pial_mesh.position.x = -100;
                rh_pial_mesh.position.x = -70;
                
                lh_inflated_mesh.position.x = 70;
                rh_inflated_mesh.position.x = 190;
                
                scene1.add(new THREE.AxesHelper(100));
                scene1.add(lh_pial_mesh);
                scene1.add(rh_pial_mesh);
                
                // scene1.add(lh_inflated_mesh);
                // scene1.add(rh_inflated_mesh);
                
                window.addEventListener("resize", function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                
                let params = { inflation: 0 };
                gui.add(params, 'inflation', 0, 1).step(0.01).onChange(value => {
                    lh_pial_mesh.material.uniforms.inflation.value = value;
                    rh_pial_mesh.material.uniforms.inflation.value = value;
                });
                
                function animate() {
                    requestAnimationFrame(animate);
                    pointlight1.position.copy(camera.position);
                    pointlight2.position.copy(camera.position);
                    
                    controls.update();
                    
                    renderer.clear();
                    renderer.render(scene2, camera);
                    renderer.clearDepth();
                    renderer.render(scene1, camera);
                }
                
                animate();
            });
            
            function loadVTK(filename) {
                return new Promise((resolve, reject) => {
                    loader.load(filename, resolve);
                });
            }
            
            function getVertices(geometry, translation) {
                let result = [];
                translation = translation || new THREE.Vector3(0, 0, 0);
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    let c = i * 3;
                    result.push(new THREE.Vector3(
                        geometry.attributes.position.array[c] + translation.x,
                        geometry.attributes.position.array[c + 1] + translation.y,
                        geometry.attributes.position.array[c + 2] + translation.z));
                }
                return result;
            }
            
            function createMaterial(geometry, type, inflated) {
                let vertshader = `
                attribute vec4 color;
                attribute vec3 morphTarget;
                attribute vec3 morphNormal;
                uniform float inflation;
                
                varying vec4 vcolor;
                varying vec3 vpos;
                varying vec3 vnorm;
                
                void main() {
                    vcolor = color;
                    vpos = position;
                    vnorm = normal;
                    
                    vec3 morphDifference = morphTarget - position;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position + morphDifference * inflation, 1.0);
                }
                `;
                let fragshader = `
                precision highp float;
                
                uniform float inflation;
                varying vec4 vcolor;
                varying vec3 vpos;
                varying vec3 vnorm;
                
                struct PointLight {
                    vec3 color;
                    vec3 position;
                    float distance;
                };
                uniform PointLight pointLights[NUM_POINT_LIGHTS];
                uniform float lightIntensity;
                
                void main() {
                    vec4 illumination = vec4(0, 0, 0, 1);
                    for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
                        vec3 direction = normalize(vpos - pointLights[i].position);
                        illumination.xyz += clamp(dot(direction, vnorm), 0.0, 1.0) * pointLights[i].color;
                    }
                    illumination.xyz *= (1.0 - inflation);
                    
                    gl_FragColor = vcolor * (illumination + vec4(inflation, inflation, inflation, 1));
                }
                `;
                
                let cols = [];
                let morphTargets = [];
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    let label = null;
                    if (type == 'l' && left_labels[i]) label = left_labels[i];
                    else if (type == 'r' && right_labels[i]) label = right_labels[i];
                    
                    if (inflated) {
                        let shift = [170, 0, 0];
                        if (type == 'r') shift = [260, 0, 0];
                        morphTargets.push(inflated.attributes.position.array[i * 3] + shift[0]);
                        morphTargets.push(inflated.attributes.position.array[i * 3 + 1] + shift[1]);
                        morphTargets.push(inflated.attributes.position.array[i * 3 + 2] + shift[2]);
                    } else {
                        morphTargets.push(geometry.attributes.position.array[i * 3]);
                        morphTargets.push(geometry.attributes.position.array[i * 3 + 1]);
                        morphTargets.push(geometry.attributes.position.array[i * 3 + 2]);
                    }
                    
                    if (label) {
                        let color = hashstring(label.basename + "!@#$%^&*()") % 0xffffff;
                        let intensity = +label.values[3];
                        if (intensity < .3) intensity = .3;
                        
                        let b = color & 8;
                        let g = (color >> 8) & 8;
                        let r = (color >> 16) & 8;
                        
                        cols.push(r * intensity);
                        cols.push(g * intensity);
                        cols.push(b * intensity);
                        cols.push(1);
                    } else {
                        cols.push(.5);
                        cols.push(.5);
                        cols.push(.5);
                        cols.push(1);
                    }
                }
                
                geometry.addAttribute('morphNormal', new THREE.BufferAttribute(geometry.attributes.normal.array.slice(), 3));
                geometry.addAttribute('morphTarget', new THREE.BufferAttribute(new Float32Array(morphTargets), 3));
                geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(cols), 4));
                return new THREE.ShaderMaterial({
                    // color: type == 'l' ? new THREE.Color(0x2194ce) : new THREE.Color(0xce2194),
                    vertexShader: vertshader,
                    fragmentShader: fragshader,
                    transparent: true,
                    lights: true,
                    uniforms: THREE.UniformsUtils.merge([
                        THREE.UniformsLib['lights'], {
                            inflation: { value: 0 },
                            lightIntensity: { value: 1 },
                        }
                    ]),
                })
            }
            
            function loadLabels(filename) {
                return new Promise(async (resolve, reject) => {
                    let file = await fetch(filename);
                    let contents = (await file.text()).replace(/[ ]+/g, " ");
                    let lines = contents.split("\n");
                    
                    for (let line of lines) {
                        let values = line.split(" ");
                        let name_without_path = filename.split("/");
                        name_without_path = name_without_path[name_without_path.length - 1];
                        
                        let basename = name_without_path.substring(name_without_path.indexOf(".") + 1);
                        
                        if (values.length == 5) {
                            if (name_without_path.startsWith("lh")) {
                                left_labels[+values[0]] = {
                                    basename,
                                    values: values.slice(1)
                                }
                            } else if (name_without_path.startsWith("rh")) {
                                right_labels[+values[0]] = {
                                    basename,
                                    values: values.slice(1)
                                }
                            }
                        }
                    }
                    
                    resolve(null);
                });
            }
            
            // function computeMorphNormals(geometry) {
            //     let norms = [];
            //     for (let i = 0; i < geometry.attributes.position.count; i += 3) {
            //         let vidx = i * 3;
            //         let A = new THREE.Vector3(geometry.attributes.position.array[vidx],
            //                                   geometry.attributes.position.array[vidx + 1],
            //                                   geometry.attributes.position.array[vidx + 2]);
            //         let B = new THREE.Vector3(geometry.attributes.position.array[vidx + 3],
            //                                   geometry.attributes.position.array[vidx + 3 + 1],
            //                                   geometry.attributes.position.array[vidx + 3 + 2]);
            //         let C = new THREE.Vector3(geometry.attributes.position.array[vidx + 6],
            //                                   geometry.attributes.position.array[vidx + 6 + 1],
            //                                   geometry.attributes.position.array[vidx + 6 + 2]);
            //         let norm = B.sub(A).cross(C.sub(A)).normalize();
                    
            //         norms.push(norm.x); norms.push(norm.y); norms.push(norm.z);
            //         norms.push(norm.x); norms.push(norm.y); norms.push(norm.z);
            //         norms.push(norm.x); norms.push(norm.y); norms.push(norm.z);
            //     }
            //     console.log(norms);
            //     // console.log(geometry.attributes.normal.count, norms.length)
            //     geometry.attributes.morphNormal.array = norms;
            //     geometry.attributes.morphNormal.needsUpdate = true;
            // }
            
            function hashstring(s) {
                var h = 0, l = s.length, i = 0;
                if ( l > 0 )
                    while (i < l)
                        h = (h << 5) - h + s.charCodeAt(i++) | 0;
                return h;
            }
            
            })();
        </script>
        
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
        </style>
    </body>
</html>