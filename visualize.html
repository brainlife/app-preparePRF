<!doctype html>
<html>
    <head>
        <title>Surface</title>
        
        <script src="node_modules/vue/dist/vue.min.js"></script>
        <script src="node_modules/three/build/three.min.js"></script>
        <script src="node_modules/async/dist/async.min.js"></script>
        <script src="node_modules/dat.gui/build/dat.gui.min.js"></script>
        <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="node_modules/three/examples/js/loaders/VTKLoader.js"></script>
    </head>
    
    <body>
        <div id="main"></div>
        <script>
            'use strict';
            
            (async _ => {
            
            let scene1 = new THREE.Scene();
            let scene2 = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 10000);
            let renderer = new THREE.WebGLRenderer();
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            let loader = new THREE.VTKLoader();
            let gui = new dat.GUI();
            
            camera.position.z = 200;
            
            renderer.setClearColor(new THREE.Color(0x222222));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("main").appendChild(renderer.domElement);
            
            let vertshader = `
            attribute vec4 color;
            varying vec4 vcolor;
            
            void main() {
                vcolor = color;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `;
            let fragshader = `
            varying vec4 vcolor;
            
            void main() {
                gl_FragColor = vcolor;
            }
            `;
            
            let labelFiles = ["lh.V1.label", "rh.V1.label"];
            // let labelFiles = ["lh.V1.label", "rh.V1.label", "lh.V2.label", "rh.V2.label", "lh.BA1.label", "rh.BA1.label", "lh.BA2.label", "rh.BA2.label", "lh.BA3a.label", "rh.BA3a.label", "lh.BA3b.label", "rh.BA3b.label", "lh.BA4a.label", "rh.BA4a.label", "lh.BA4p.label", "rh.BA4p.label", "lh.BA4p.thresh.label", "rh.BA4p.thresh.label", "lh.BA6.label", "rh.BA6.label", "lh.BA44.label", "rh.BA44.label", "lh.BA45.label", "rh.BA45.label", "lh.BA6.label", "rh.BA6.label", "lh.entorhinal_exvivo.label", "rh.entorhinal_exvivo.label", "lh.MT.label", "rh.MT.label", "lh.perirhinal.label", "rh.perirhinal.label"];
            // let labelFiles = ["rh.BA44.label", "lh.BA44.label", "lh.BA3b.thresh.label", "rh.BA6.thresh.label", "rh.BA45.label", "rh.BA2.thresh.label", "lh.entorhinal_exvivo.label", "lh.BA45.label", "lh.BA3a.thresh.label", "rh.V2.label", "rh.BA45.thresh.label", "rh.BA3b.label", "rh.BA1.thresh.label", "rh.BA1.label", "rh.BA44.thresh.label", "rh.BA2.label", "lh.BA3b.label", "rh.perirhinal.label", "rh.V1.label", "lh.BA6.label", "lh.BA3a.label", "rh.MT.label", "rh.BA4p.thresh.label", "rh.BA4p.label", "rh.BA3a.label", "lh.BA4p.label", "rh.BA4a.thresh.label", "lh.BA4a.thresh.label", "rh.entorhinal_exvivo.label", "lh.perirhinal.label", "rh.aparc.a2009s.annot", "lh.V1.label", "lh.BA1.label", "rh.cortex.prehires.label", "rh.cortex.deformed.label", "lh.cortex.prehires.label", "lh.aparc.annot", "lh.BA4p.thresh.label", "lh.MT.label", "lh.BA45.thresh.label", "lh.BA2.label", "rh.MT.thresh.label", "rh.BA6.label", "lh.V2.label", "lh.MT.thresh.label", "lh.BA6.thresh.label", "lh.BA44.thresh.label", "rh.V1.thresh.label", "rh.BA4a.label", "lh.cortex.deformed.label", "lh.V2.thresh.label", "lh.BA4a.label", "lh.BA2.thresh.label", "rh.V2.thresh.label", "rh.BA3b.thresh.label", "rh.BA3a.thresh.label", "lh.V1.thresh.label", "lh.BA1.thresh.label", "lh.cortex.label", "rh.cortex.label"]
            let left_labels = {};
            let right_labels = {};
            
            async.eachLimit(labelFiles, 10, function(filename, next_file) {
                console.log("loading", filename);
                loadLabels("input/output/label/" + filename)
                .then(_ => {
                    next_file();
                });
            }, async function(err) {
                if (err) console.error(err);
                console.log("loading lh.pial");
                let lh_pial_geometry = await loadVTK('input/output/surf/lh.pial.vtk');
                
                console.log("loading rh.pial");
                let rh_pial_geometry = await loadVTK('input/output/surf/rh.pial.vtk');
                
                console.log("loading lh.inflated");
                let lh_inflated_geometry = await loadVTK('input/output/surf/lh.inflated.vtk');
                
                console.log("loading rh.inflated");
                let rh_inflated_geometry = await loadVTK('input/output/surf/rh.inflated.vtk');
                
                let pointlight1 = new THREE.PointLight(0xffffff, 1);
                let pointlight2 = new THREE.PointLight(0xffffff, 1);
                
                let pial_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x2194ce), transparent: true, opacity: .7 });
                let inflated_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x9421ce), transparent: true, opacity: .7 });
                
                let tmp = new THREE.Geometry();
                tmp = tmp.fromBufferGeometry(lh_pial_geometry);
                tmp.computeVertexNormals();
                lh_pial_geometry = tmp;
                
                tmp = new THREE.Geometry();
                tmp = tmp.fromBufferGeometry(rh_pial_geometry);
                tmp.computeVertexNormals();
                rh_pial_geometry = tmp;
                
                renderer.autoClear = false;
                
                lh_pial_geometry.computeVertexNormals();
                rh_pial_geometry.computeVertexNormals();
                
                lh_inflated_geometry.computeVertexNormals();
                rh_inflated_geometry.computeVertexNormals();
                
                pointlight1.position.copy(camera.position);
                pointlight2.position.copy(camera.position);
                
                console.log(lh_pial_geometry);
                console.log(lh_inflated_geometry);
                
                let params = {
                    inflation: 0,
                }
                
                lh_pial_geometry.morphTargets.push({ name: "lh_inflated", vertices: getVertices(lh_inflated_geometry, new THREE.Vector3(170, 0, 0)).slice() });
                rh_pial_geometry.morphTargets.push({ name: "rh_inflated", vertices: getVertices(rh_inflated_geometry, new THREE.Vector3(260, 0, 0)).slice() });
                
                let lh_pial_mesh = new THREE.Mesh(lh_pial_geometry, createMaterial(lh_pial_geometry, 'l'));
                let rh_pial_mesh = new THREE.Mesh(rh_pial_geometry, createMaterial(rh_pial_geometry, 'r'));
                
                console.log(lh_pial_mesh);
                
                let lh_inflated_mesh = new THREE.Mesh(lh_inflated_geometry, createMaterial(lh_inflated_geometry, 'l'));
                let rh_inflated_mesh = new THREE.Mesh(rh_inflated_geometry, createMaterial(rh_inflated_geometry, 'r'));
                
                lh_pial_mesh.position.x = -100;
                rh_pial_mesh.position.x = -70;
                
                lh_inflated_mesh.position.x = 70;
                rh_inflated_mesh.position.x = 190;
                
                scene1.add(new THREE.AxesHelper(100));
                scene1.add(lh_pial_mesh);
                scene1.add(rh_pial_mesh);
                
                // scene1.add(lh_inflated_mesh);
                // scene1.add(rh_inflated_mesh);
                
                scene1.add(pointlight1);
                scene2.add(pointlight2);
                
                window.addEventListener("resize", function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                gui.add(params, 'inflation', 0, 1).step(0.01).onChange(value => {
                    lh_pial_mesh.morphTargetInfluences[0] = value;
                    rh_pial_mesh.morphTargetInfluences[0] = value;
                    
                    lh_pial_geometry.computeVertexNormals();
                    rh_pial_geometry.computeVertexNormals();
                    
                    lh_pial_geometry.computeMorphNormals();
                    rh_pial_geometry.computeMorphNormals();
                });
                
                function animate() {
                    requestAnimationFrame(animate);
                    pointlight1.position.copy(camera.position);
                    pointlight2.position.copy(camera.position);
                    controls.update();
                    
                    renderer.clear();
                    renderer.render(scene2, camera);
                    renderer.clearDepth();
                    renderer.render(scene1, camera);
                }
                
                animate();
            });
            
            function loadVTK(filename) {
                return new Promise((resolve, reject) => {
                    loader.load(filename, resolve);
                });
            }
            
            function getVertices(geometry, translation) {
                let result = [];
                translation = translation || new THREE.Vector3(0, 0, 0);
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    let c = i * 3;
                    result.push(new THREE.Vector3(
                        geometry.attributes.position.array[c] + translation.x,
                        geometry.attributes.position.array[c + 1] + translation.y,
                        geometry.attributes.position.array[c + 2] + translation.z));
                }
                return result;
            }
            
            function createMaterial(geometry, type) {
                let cols = [];
                // for (let i = 0; i < geometry.attributes.position.count; i++) {
                //     let label = null;
                //     if (type == 'l' && left_labels[i]) label = left_labels[i];
                //     else if (type == 'r' && right_labels[i]) label = right_labels[i];
                    
                //     if (label) {
                //         let color = hashstring(label.basename + "...") % 0xffffff;
                //         let intensity = +label.values[3];
                //         if (intensity < .3) intensity = .3;
                        
                //         let b = color & 8;
                //         let g = (color >> 8) & 8;
                //         let r = (color >> 16) & 8;
                        
                //         cols.push(r * intensity);
                //         cols.push(g * intensity);
                //         cols.push(b * intensity);
                //         cols.push(1);
                //     } else {
                //         cols.push(.5);
                //         cols.push(.5);
                //         cols.push(.5);
                //         cols.push(1);
                //     }
                // }
                
                // geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(cols), 4));
                return new THREE.MeshLambertMaterial({
                    transparent: true,
                    color: type == 'l' ? new THREE.Color(0x2194ce) : new THREE.Color(0xce2194),
                    // vertexShader: vertshader,
                    // fragmentShader: fragshader,
                    morphTargets: true,
                    morphNormals: true,
                    vertexColors: THREE.FaceColors
                })
            }
            
            function loadLabels(filename) {
                return new Promise(async (resolve, reject) => {
                    let file = await fetch(filename);
                    let contents = (await file.text()).replace(/[ ]+/g, " ");
                    let lines = contents.split("\n");
                    
                    for (let line of lines) {
                        let values = line.split(" ");
                        let name_without_path = filename.split("/");
                        name_without_path = name_without_path[name_without_path.length - 1];
                        
                        let basename = name_without_path.substring(name_without_path.indexOf(".") + 1);
                        
                        if (values.length == 5) {
                            if (name_without_path.startsWith("lh")) {
                                left_labels[+values[0]] = {
                                    basename,
                                    values: values.slice(1)
                                }
                            } else if (name_without_path.startsWith("rh")) {
                                right_labels[+values[0]] = {
                                    basename,
                                    values: values.slice(1)
                                }
                            }
                        }
                    }
                    
                    resolve(null);
                });
            }
            
            function hashstring(s) {
                var h = 0, l = s.length, i = 0;
                if ( l > 0 )
                    while (i < l)
                        h = (h << 5) - h + s.charCodeAt(i++) | 0;
                return h;
            }
            
            })();
        </script>
        
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
        </style>
    </body>
</html>