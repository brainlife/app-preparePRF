<!doctype html>
<html>
    <head>
        <title>Surface</title>
        
        <script src="node_modules/vue/dist/vue.min.js"></script>
        <script src="node_modules/three/build/three.min.js"></script>
        <script src="node_modules/async/dist/async.min.js"></script>
        <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="node_modules/three/examples/js/loaders/VTKLoader.js"></script>
    </head>
    
    <body>
        <div id="main"></div>
        <script>
            'use strict';
            
            (async _ => {
            
            let scene1 = new THREE.Scene();
            let scene2 = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 10000);
            let renderer = new THREE.WebGLRenderer();
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            let loader = new THREE.VTKLoader();
            
            camera.position.z = 200;
            
            renderer.setClearColor(new THREE.Color(0));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("main").appendChild(renderer.domElement);
            
            let vertshader = `
            attribute vec4 color;
            varying vec4 vcolor;
            
            void main() {
                vcolor = color;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
            `;
            let fragshader = `
            varying vec4 vcolor;
            
            void main() {
                gl_FragColor = vcolor;
            }
            `;
            
            let labelFiles = ["lh.V1.label", "rh.V1.label"];
            let labels = {};
            
            async.eachLimit(labelFiles, 10, async (filename, next_file) => {
                await loadLabels("input/output/label/" + filename);
                next_file();
            }, async function() {
                let lh_pial_geometry = await loadVTK('input/output/surf/lh.pial.vtk');
                let rh_pial_geometry = await loadVTK('input/output/surf/rh.pial.vtk');
                
                let lh_inflated_geometry = await loadVTK('input/output/surf/lh.inflated.vtk');
                let rh_inflated_geometry = await loadVTK('input/output/surf/rh.inflated.vtk');
                
                let pointlight1 = new THREE.PointLight(0xffffff, 1);
                let pointlight2 = new THREE.PointLight(0xffffff, 1);
                
                let pial_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x2194ce), transparent: true, opacity: .7 });
                let inflated_material = new THREE.MeshLambertMaterial({ color: new THREE.Color(0x9421ce), transparent: true, opacity: .7 });
                
                renderer.autoClear = false;
                
                lh_pial_geometry.computeVertexNormals();
                rh_pial_geometry.computeVertexNormals();
                
                lh_inflated_geometry.computeVertexNormals();
                rh_inflated_geometry.computeVertexNormals();
                
                pointlight1.position.copy(camera.position);
                pointlight2.position.copy(camera.position);
                
                console.log(lh_pial_geometry);
                console.log(lh_inflated_geometry);
                
                let lh_pial_mesh = new THREE.Mesh(lh_pial_geometry, createMaterial(lh_pial_geometry, 'l'));
                let rh_pial_mesh = new THREE.Mesh(rh_pial_geometry, createMaterial(rh_pial_geometry, 'r'));
                
                let lh_inflated_mesh = new THREE.Mesh(lh_inflated_geometry, createMaterial(lh_inflated_geometry, 'l'));
                let rh_inflated_mesh = new THREE.Mesh(rh_inflated_geometry, createMaterial(rh_inflated_geometry, 'r'));
                
                lh_pial_mesh.position.x = -100;
                rh_pial_mesh.position.x = -100;
                
                lh_inflated_mesh.position.x = 100;
                rh_inflated_mesh.position.x = 100;
                
                scene1.add(new THREE.AxesHelper(100));
                scene1.add(lh_pial_mesh);
                scene1.add(rh_pial_mesh);
                
                scene1.add(lh_inflated_mesh);
                scene1.add(rh_inflated_mesh);
                
                scene1.add(pointlight1);
                scene2.add(pointlight2);
                
                window.addEventListener("resize", function() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                function animate() {
                    requestAnimationFrame(animate);
                    pointlight1.position.copy(camera.position);
                    pointlight2.position.copy(camera.position);
                    controls.update();
                    
                    renderer.clear();
                    renderer.render(scene2, camera);
                    renderer.clearDepth();
                    renderer.render(scene1, camera);
                }
                
                animate();
            });
            
            function loadVTK(filename) {
                return new Promise((resolve, reject) => {
                    loader.load(filename, resolve);
                });
            }
            
            function createMaterial(geometry, type) {
                let cols = [];
                for (let i = 0; i < geometry.attributes.position.count; i++) {
                    if (labels) {
                        if (labels[i] && (type == 'l' && labels[i].left || type == 'r' && labels[i].right)) {
                            let color = hashstring(labels[i].basename) % 0xffffff;
                            let intensity = +labels[i].values[3];
                            let b = color & 8;
                            let g = (color >> 8) & 8;
                            let r = (color >> 16) & 8;
                            
                            cols.push(r * intensity);
                            cols.push(g * intensity);
                            cols.push(b * intensity);
                            cols.push(1);
                        } else {
                            cols.push(.5);
                            cols.push(.5);
                            cols.push(.5);
                            cols.push(1);
                        }
                    } else {
                        let val = Math.floor(i / geometry.attributes.position.count * 0xffffff);
                        let b = val & 8;
                        let g = (val >> 8) & 8;
                        let r = (val >> 16) & 8;
                        
                        cols.push(r);
                        cols.push(g);
                        cols.push(b);
                        cols.push(.5);
                    }
                }
                
                geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(cols), 4));
                return new THREE.ShaderMaterial({
                    transparent: true,
                    vertexShader: vertshader,
                    fragmentShader: fragshader
                })
            }
            
            function loadLabels(filename) {
                return new Promise(async (resolve, reject) => {
                    let file = await fetch(filename);
                    let contents = (await file.text()).replace(/[ ]+/g, " ");
                    let lines = contents.split("\n");
                    
                    for (let line of lines) {
                        let values = line.split(" ");
                        let name_without_path = filename.split("/");
                        name_without_path = name_without_path[name_without_path.length - 1];
                        
                        if (values.length == 5) {
                            labels[+values[0]] = {
                                left: name_without_path.startsWith("lh"),
                                right: name_without_path.startsWith("rh"),
                                basename: name_without_path.substring(name_without_path.indexOf(".") + 1),
                                values: values.slice(1)
                            }
                        }
                    }
                    
                    resolve(labels);
                });
            }
            
            function hashstring(s) {
                var h = 0, l = s.length, i = 0;
                if ( l > 0 )
                    while (i < l)
                        h = (h << 5) - h + s.charCodeAt(i++) | 0;
                return h;
            }
            
            })();
        </script>
        
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }
        </style>
    </body>
</html>